#!/usr/bin/env node

/**
 * üß™ TESTAR RESPOSTA SIMULADA
 * 
 * Este script simula uma resposta para testar se a lista de confirma√ß√µes
 * √© gerada automaticamente ap√≥s cada resposta.
 */

const { createClient } = require('@supabase/supabase-js');
const moment = require('moment');
moment.locale('pt-br');

class TestarRespostaSimulada {
    constructor() {
        // Configurar Supabase
        const supabaseUrl = 'https://ddlxamlaoumhbbrnmasj.supabase.co';
        const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRkbHhhbWxhb3VtaGJicm5tYXNqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY5NDAwMzcsImV4cCI6MjA3MjUxNjAzN30.VrTmCTDl0zkzP1GQ8YHAqFLbtCUlaYIp7v_4rUHbSMo';

        this.supabase = createClient(supabaseUrl, supabaseAnonKey);
    }

    async testarRespostaSimulada() {
        try {
            console.log('üß™ ===== TESTANDO RESPOSTA SIMULADA =====\n');
            
            // 1. Buscar sess√£o ativa
            const sessao = await this.buscarSessaoAtiva();
            if (!sessao) {
                console.log('‚ùå Nenhuma sess√£o ativa encontrada');
                return;
            }
            
            // 2. Buscar confirma√ß√£o pendente
            const confirmacao = await this.buscarConfirmacaoPendente(sessao.id);
            if (!confirmacao) {
                console.log('‚ùå Nenhuma confirma√ß√£o pendente encontrada');
                return;
            }
            
            // 3. Simular resposta "SIM"
            await this.simularRespostaSim(confirmacao);
            
            // 4. Aguardar um pouco e simular resposta "N√ÉO" de outro jogador
            console.log('\n‚è≥ Aguardando 3 segundos...');
            await this.aguardar(3000);
            
            // 5. Verificar se h√° mais confirma√ß√µes pendentes
            const outraConfirmacao = await this.buscarOutraConfirmacaoPendente(sessao.id, confirmacao.player_id);
            if (outraConfirmacao) {
                await this.simularRespostaNao(outraConfirmacao);
            }
            
            // 6. Exibir lista final
            await this.exibirListaFinal(sessao.id);
            
            console.log('\nüß™ ===== TESTE CONCLU√çDO =====\n');
            
        } catch (error) {
            console.error('‚ùå Erro durante o teste:', error);
        }
    }

    /**
     * 1. Buscar sess√£o ativa
     */
    async buscarSessaoAtiva() {
        try {
            console.log('üîç 1. BUSCANDO SESS√ÉO ATIVA:');
            
            const { data: sessoes, error } = await this.supabase
                .from('game_sessions')
                .select(`
                    id,
                    session_date,
                    start_time,
                    games!inner(
                        organization_name,
                        location
                    )
                `)
                .eq('status', 'scheduled')
                .gte('session_date', moment().format('YYYY-MM-DD'))
                .order('session_date', { ascending: true })
                .limit(1);
            
            if (error || !sessoes || sessoes.length === 0) {
                console.log('   ‚ùå Erro ao buscar sess√µes:', error?.message);
                return null;
            }
            
            const sessao = sessoes[0];
            console.log(`   ‚úÖ Sess√£o encontrada: ${sessao.id}`);
            console.log(`   üéÆ Jogo: ${sessao.games.organization_name}`);
            console.log(`   üìÖ Data: ${sessao.session_date} ${sessao.start_time}`);
            
            return sessao;
            
        } catch (error) {
            console.error('   ‚ùå Erro ao buscar sess√£o ativa:', error);
            return null;
        }
    }

    /**
     * 2. Buscar confirma√ß√£o pendente
     */
    async buscarConfirmacaoPendente(sessionId) {
        try {
            console.log('\nüîç 2. BUSCANDO CONFIRMA√á√ÉO PENDENTE:');
            
            const { data: confirmacoes, error } = await this.supabase
                .from('participation_confirmations')
                .select(`
                    id,
                    session_id,
                    player_id,
                    player_phone,
                    player_type,
                    status,
                    players!inner(
                        name,
                        phone_number,
                        type
                    )
                `)
                .eq('session_id', sessionId)
                .eq('status', 'pending')
                .limit(1);
            
            if (error || !confirmacoes || confirmacoes.length === 0) {
                console.log('   ‚ùå Erro ao buscar confirma√ß√µes pendentes:', error?.message);
                return null;
            }
            
            const confirmacao = confirmacoes[0];
            console.log(`   ‚úÖ Confirma√ß√£o encontrada: ${confirmacao.id}`);
            console.log(`   üë§ Jogador: ${confirmacao.players.name} (${confirmacao.players.phone_number})`);
            console.log(`   üì± Telefone: ${confirmacao.player_phone}`);
            console.log(`   üéØ Tipo: ${confirmacao.player_type}`);
            
            return confirmacao;
            
        } catch (error) {
            console.error('   ‚ùå Erro ao buscar confirma√ß√£o pendente:', error);
            return null;
        }
    }

    /**
     * 3. Simular resposta "SIM"
     */
    async simularRespostaSim(confirmacao) {
        try {
            console.log('\n‚úÖ 3. SIMULANDO RESPOSTA "SIM":');
            
            const status = 'confirmed';
            const now = moment().toISOString();
            
            // Usar UPDATE em vez de UPSERT para evitar constraint √∫nica
            const { error } = await this.supabase
                .from('participation_confirmations')
                .update({
                    status: status,
                    confirmed_at: now,
                    updated_at: now
                })
                .eq('session_id', confirmacao.session_id)
                .eq('player_phone', confirmacao.player_phone);
            
            if (error) {
                console.log('   ‚ùå Erro ao atualizar confirma√ß√£o:', error.message);
                return;
            }
            
            console.log(`   ‚úÖ ${confirmacao.players.name} confirmou presen√ßa!`);
            console.log(`   üìù Status atualizado para: ${status}`);
            console.log(`   ‚è∞ Confirmado em: ${moment(now).format('DD/MM/YYYY HH:mm:ss')}`);
            
        } catch (error) {
            console.error('   ‚ùå Erro ao simular resposta SIM:', error);
        }
    }

    /**
     * 4. Buscar outra confirma√ß√£o pendente
     */
    async buscarOutraConfirmacaoPendente(sessionId, excludePlayerId) {
        try {
            console.log('\nüîç 4. BUSCANDO OUTRA CONFIRMA√á√ÉO PENDENTE:');
            
            const { data: confirmacoes, error } = await this.supabase
                .from('participation_confirmations')
                .select(`
                    id,
                    session_id,
                    player_id,
                    player_phone,
                    player_type,
                    status,
                    players!inner(
                        name,
                        phone_number,
                        type
                    )
                `)
                .eq('session_id', sessionId)
                .eq('status', 'pending')
                .neq('player_id', excludePlayerId)
                .limit(1);
            
            if (error || !confirmacoes || confirmacoes.length === 0) {
                console.log('   üìù Nenhuma outra confirma√ß√£o pendente encontrada');
                return null;
            }
            
            const confirmacao = confirmacoes[0];
            console.log(`   ‚úÖ Outra confirma√ß√£o encontrada: ${confirmacao.id}`);
            console.log(`   üë§ Jogador: ${confirmacao.players.name} (${confirmacao.players.phone_number})`);
            
            return confirmacao;
            
        } catch (error) {
            console.error('   ‚ùå Erro ao buscar outra confirma√ß√£o pendente:', error);
            return null;
        }
    }

    /**
     * 5. Simular resposta "N√ÉO"
     */
    async simularRespostaNao(confirmacao) {
        try {
            console.log('\n‚ùå 5. SIMULANDO RESPOSTA "N√ÉO":');
            
            const status = 'declined';
            const now = moment().toISOString();
            
            // Usar UPDATE em vez de UPSERT para evitar constraint √∫nica
            const { error } = await this.supabase
                .from('participation_confirmations')
                .update({
                    status: status,
                    declined_at: now,
                    updated_at: now
                })
                .eq('session_id', confirmacao.session_id)
                .eq('player_phone', confirmacao.player_phone);
            
            if (error) {
                console.log('   ‚ùå Erro ao atualizar confirma√ß√£o:', error.message);
                return;
            }
            
            console.log(`   ‚ùå ${confirmacao.players.name} recusou presen√ßa!`);
            console.log(`   üìù Status atualizado para: ${status}`);
            console.log(`   ‚è∞ Recusado em: ${moment(now).format('DD/MM/YYYY HH:mm:ss')}`);
            
        } catch (error) {
            console.error('   ‚ùå Erro ao simular resposta N√ÉO:', error);
        }
    }

    /**
     * 6. Exibir lista final
     */
    async exibirListaFinal(sessionId) {
        try {
            console.log('\nüìã 6. LISTA FINAL DE CONFIRMA√á√ïES:');
            
            const { data: confirmacoes, error } = await this.supabase
                .from('participation_confirmations')
                .select(`
                    status,
                    confirmed_at,
                    declined_at,
                    players!inner(
                        name,
                        phone_number,
                        type
                    )
                `)
                .eq('session_id', sessionId);
            
            if (error) {
                console.log('   ‚ùå Erro ao buscar confirma√ß√µes:', error.message);
                return;
            }
            
            if (!confirmacoes || confirmacoes.length === 0) {
                console.log('   üìù Nenhuma confirma√ß√£o encontrada');
                return;
            }
            
            // Separar por status
            const confirmados = confirmacoes.filter(c => c.status === 'confirmed');
            const recusados = confirmacoes.filter(c => c.status === 'declined');
            const pendentes = confirmacoes.filter(c => c.status === 'pending');
            
            console.log(`\n   ‚úÖ DENTRO DA PARTIDA (${confirmados.length}):`);
            confirmados.forEach((conf, index) => {
                console.log(`      ${index + 1}. ${conf.players.name} (${conf.players.phone_number}) - ${conf.players.type}`);
            });
            
            console.log(`\n   ‚ùå FORA DA PARTIDA (${recusados.length}):`);
            recusados.forEach((conf, index) => {
                console.log(`      ${index + 1}. ${conf.players.name} (${conf.players.phone_number}) - ${conf.players.type}`);
            });
            
            console.log(`\n   ‚è≥ PENDENTES (${pendentes.length}):`);
            pendentes.forEach((conf, index) => {
                console.log(`      ${index + 1}. ${conf.players.name} (${conf.players.phone_number}) - ${conf.players.type}`);
            });
            
            console.log(`\n   üìä RESUMO:`);
            console.log(`      ‚úÖ Dentro da partida: ${confirmados.length}`);
            console.log(`      ‚ùå Fora da partida: ${recusados.length}`);
            console.log(`      ‚è≥ Pendentes: ${pendentes.length}`);
            console.log(`      üìù Total: ${confirmacoes.length}`);
            
        } catch (error) {
            console.error('   ‚ùå Erro ao exibir lista final:', error);
        }
    }

    /**
     * Fun√ß√£o auxiliar para aguardar
     */
    aguardar(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// Executar teste
async function main() {
    const teste = new TestarRespostaSimulada();
    await teste.testarRespostaSimulada();
}

// Executar se este arquivo for chamado diretamente
if (require.main === module) {
    main().catch(console.error);
}

module.exports = TestarRespostaSimulada;
